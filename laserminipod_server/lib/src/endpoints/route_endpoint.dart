import 'package:laserminipod_server/src/generated/protocol.dart';
import 'package:serverpod/serverpod.dart';

class RouteEndpoint extends Endpoint {
  /// Deletes a route from the `spraywallroute` table based on its ID.
  Future<void> deleteRoute(Session session, int id) async {
    try {
      session.log('Attempting to delete route with ID: $id',
          level: LogLevel.info);
      await SpraywallRoute.db.deleteWhere(
        session,
        where: (t) => t.id.equals(id),
      );
      session.log('Route with ID: $id successfully deleted',
          level: LogLevel.info);
    } catch (e) {
      session.log('Error deleting route with ID: $id. Error: $e',
          level: LogLevel.error);
    }
  }

  Future<bool> saveRoute(Session session, SpraywallRoute route) async {
    try {
      session.log('Attempting to save route: ${route.name}',
          level: LogLevel.info);
      await SpraywallRoute.db.insert(session, [route]);
      session.log('Route saved successfully: ${route.name}',
          level: LogLevel.info);
      return true;
    } catch (e) {
      session.log('Error saving the route: $e', level: LogLevel.error);
      return false;
    }
  }

  /// Returns a new unique ID for a route.
  /// (Optional: Only needed if IDs are not auto-generated by the database.)
  Future<int> getNewId(Session session) async {
    try {
      session.log('Fetching a new unique ID for a route', level: LogLevel.info);
      var maxIdResult = await session.db.unsafeQuery(
        'SELECT MAX(id) AS max_id FROM spraywallroute',
      );
      var newId =
          (maxIdResult.isNotEmpty ? (maxIdResult.first as int?) : 0)! + 1;
      session.log('Generated new unique ID: $newId', level: LogLevel.info);
      return newId;
    } catch (e) {
      session.log('Error while generating a new unique ID. Error: $e',
          level: LogLevel.error);
      return -1; // Indicates an error
    }
  }

  Future<List<SpraywallRoute>> loadAllRoutes(Session session) async {
    try {
      session.log('Loading all routes from the database', level: LogLevel.info);
      var routes = await SpraywallRoute.db.find(session);
      session.log('Loaded ${routes.length} routes from the database',
          level: LogLevel.info);
      return routes;
    } catch (e) {
      session.log('Failed to load routes. Error: $e', level: LogLevel.error);
      return [];
    }
  }

  /// Checks if a route with the same handles already exists.
  /// Routes are considered equal if they consist of the same handles.
  Future<bool> existsRouteAlready(Session session, SpraywallRoute route) async {
    try {
      session.log('Checking if a route with the same handles already exists',
          level: LogLevel.info);
      var allRoutes = await SpraywallRoute.db.find(session);

      for (var existingRoute in allRoutes) {
        if (_compareLists(existingRoute.handles, route.handles)) {
          session.log('A route with the same handles already exists',
              level: LogLevel.info);
          return true;
        }
      }

      session.log('No route with the same handles found', level: LogLevel.info);
      return false;
    } catch (e) {
      session.log('Error while checking for duplicate routes. Error: $e',
          level: LogLevel.error);
      return false;
    }
  }

  /// Checks if a given name is already assigned to a route.
  Future<bool> nameAlreadyAssigned(Session session, String name) async {
    try {
      session.log('Checking if the name "$name" is already assigned to a route',
          level: LogLevel.info);
      var existingRoutes = await SpraywallRoute.db.find(
        session,
        where: (t) => t.name.equals(name),
      );

      if (existingRoutes.isNotEmpty) {
        session.log('The name "$name" is already assigned to a route',
            level: LogLevel.warning);
        return true;
      } else {
        session.log('The name "$name" is not assigned to any route',
            level: LogLevel.info);
        return false;
      }
    } catch (e) {
      session.log('Error while checking for name assignment. Error: $e',
          level: LogLevel.error);
      return false;
    }
  }

  /// Test function to check communication.
  Future<void> test(Session session) async {
    session.log('Test endpoint called: Communication is working!',
        level: LogLevel.info);
  }

  /// compares two lists, order and duplicates don't matter
  bool _compareLists(List list1, List list2) {
    return Set.from(list1).containsAll(list2) &&
        Set.from(list2).containsAll(list1);
  }
}
