import 'package:laserminipod_server/src/generated/protocol.dart';
import 'package:serverpod/serverpod.dart';

class RouteEndpoint extends Endpoint {
  /// Deletes a route from the `spraywallroute` table based on its ID.
  Future<void> deleteRoute(Session session, int id) async {
    await SpraywallRoute.db.deleteWhere(
      session,
      where: (t) => t.id.equals(id),
    );
  }

  /// Loads a specific route by its ID.
  Future<SpraywallRoute?> loadRoute(Session session, int id) async {
    return await SpraywallRoute.db.findById(session, id);
  }

  /// Saves a new route into the database.
  Future<bool> saveRoute(Session session, SpraywallRoute route) async {
    try {
      await SpraywallRoute.db.insert(session, [route]);
      return true;
    } catch (e) {
      session.log('Error saving the route: $e');
      return false;
    }
  }

  /// Returns a new unique ID for a route.
  /// (Optional: Only needed if IDs are not auto-generated by the database.)
  Future<int> getNewId(Session session) async {
    var maxIdResult = await session.db.unsafeQuery(
      'SELECT MAX(id) AS max_id FROM spraywallroute',
    );
    return (maxIdResult.isNotEmpty ? (maxIdResult.first as int?) : 0)! + 1;
  }

  /// Loads all routes from the `spraywallroute` table.
  Future<List<SpraywallRoute>> loadAllRoutes(Session session) async {
    return await SpraywallRoute.db.find(session);
  }

  /// Checks if a route with the same handles already exists.
  /// Routes are considered equal if they consist of the same handles.
  Future<bool> existsRouteAlready(Session session, SpraywallRoute route) async {
    var allRoutes = await SpraywallRoute.db.find(session);

    for (var existingRoute in allRoutes) {
      if (_compareLists(existingRoute.handles, route.handles)) {
        return true;
      }
    }

    return false;
  }

  /// Checks if a given name is already assigned to a route.
  Future<bool> nameAlreadyAssigned(Session session, String name) async {
    var existingRoutes = await SpraywallRoute.db.find(
      session,
      where: (t) => t.name.equals(name),
    );
    return existingRoutes.isNotEmpty;
  }

  /// Test function to check communication.
  Future<void> test(Session session) async {
    print("Communication is working!");
  }

  /// compares two lists, order and duplicates don't matter
  bool _compareLists(List list1, List list2) {
    return Set.from(list1).containsAll(list2) &&
        Set.from(list2).containsAll(list1);
  }
}
